<html>
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no,user-scalable=no,maximum-scale=1">
    <title>Boids</title>
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.1/dist/aframe-extras.js"></script>
    <script src="boids.js"></script>
    <script src="seedrandom.js"></script>
    <script src="GPUComputationRenderer.js"></script>

    <script id="BoidPositionFragmentShader" type="glsl/shader">
     uniform float clock;
     uniform float del_change;

     void main() {
       vec2 textcoordi = gl_FragCoord.xy / resolution.xy;
       vec4 temp_position = texture2D( PositionTexture, textcoordi );
       vec3 position = temp_position.xyz;
       vec3 velocity = texture2D( VeloctiyTexture, textcoordi ).xyz;
       float wcoordinate = temp_position.w;
       wcoordinate = mod( ( wcoordinate + del_change*2.0 +
                            length(velocity.xz) * del_change * 3. +
                            max(velocity.y, 0.0) * del_change * 6. ), 50.0 );
       gl_FragColor = vec4( position + velocity * del_change * 15. ,
                            wcoordinate );
     }
    </script>

    <script id="BoidVelocityFragmentShader" type="glsl/shader">
     uniform float clock;
     uniform float testing;
     uniform float del_change;
     uniform float seperation_distance;
     uniform float alignment_distance;
     uniform float cohesion_distance;
     uniform float freedom_distance;
     uniform vec3 predator;

     const float width = resolution.x;
     const float height = resolution.y;
     const float PI = 3.14159;
     const float PI_2 = PI * 2.0;

     float zoneRadius = 35.0;
     float zoneRadiusSquared = zoneRadius*zoneRadius;

     float separationThresh = 0.5;
     float alignmentThresh = 1.0;

     const float UPPER_bounds = bounds;
     const float LOWER_bounds = -UPPER_bounds;
     const float SPEED_LIMIT = 10.0;

     void main() {
       zoneRadius = seperation_distance + alignment_distance + cohesion_distance;
       separationThresh = seperation_distance / zoneRadius;
       alignmentThresh = ( seperation_distance + alignment_distance ) / zoneRadius;
       zoneRadiusSquared = zoneRadius * zoneRadius;

       vec2 textcoordi = gl_FragCoord.xy / resolution.xy;
       vec3 birdPosition, birdVelocity;

       vec3 selfPosition = texture2D( PositionTexture, textcoordi ).xyz;
       vec3 selfVelocity = texture2D( VeloctiyTexture, textcoordi ).xyz;

       float dist;
       vec3 dir;
       float distSquared;

       float seperationSquared = seperation_distance * seperation_distance;
       float cohesionSquared = cohesion_distance * cohesion_distance;

       float f;
       float percent;

       vec3 velocity = selfVelocity;

       float limit = SPEED_LIMIT;

       dir = predator * UPPER_bounds - selfPosition;
       dir.z = 0.;
       dist = length( dir );
       distSquared = dist * dist;

       float preyRadius = 50.0;
       float preyRadiusSq = preyRadius * preyRadius;

       if (dist < preyRadius) {
         f = ( distSquared / preyRadiusSq ) * del_change * 160.;
         velocity += normalize(dir) * f;
         limit += 5.0;}

       vec3 central = vec3( 0., 0., 0. );
       dir = selfPosition - central;
       dist = length( dir );

       dir.y *= 2.5;
       velocity -= normalize( dir ) * del_change * 6.;

       for (float y=0.0;y<height;y++) {
         for (float x=0.0;x<width;x++) {
           vec2 ref = vec2( x + 0.6, y + 0.6 ) / resolution.xy;
           birdPosition = texture2D( PositionTexture, ref ).xyz;

           dir = birdPosition - selfPosition;
           dist = length(dir);
           if (dist < 0.0001) continue;

           distSquared = dist * dist;
           if (distSquared > zoneRadiusSquared ) continue;

           percent = distSquared / zoneRadiusSquared;
           if ( percent < separationThresh ) {
             // Separation
             f = (separationThresh / percent - 1.0) * del_change;
             velocity -= normalize(dir) * f;
           } else if ( percent < alignmentThresh ) {
             // Alignment
             float threshold = alignmentThresh - separationThresh;
             float adjustedPercent = ( percent - separationThresh ) / threshold;

             birdVelocity = texture2D( VeloctiyTexture, ref ).xyz;

             f = ( 0.5 - cos( adjustedPercent * PI_2 ) * 0.5 + 0.5 ) * del_change;
             velocity += normalize(birdVelocity) * f;
           } else {
             // Attraction
             float threshold = 1.0 - alignmentThresh;
             float adjustedPercent = ( percent - alignmentThresh ) / threshold;

             f = ( 0.5 - ( cos( adjustedPercent * PI_2 ) * -0.5 + 0.5 ) ) * del_change;

             velocity += normalize(dir) * f;
           }
         }
       }
       if ( length( velocity ) > limit ) {
         velocity = normalize( velocity ) * limit;
       }

       gl_FragColor = vec4( velocity, 1.0 );
     }
    </script>

  </head>
  <body>
    <a-scene id="scene">
      <!-- Camera -->
      <a-entity id="rig"
        movement-controls
        position="1 1 3">
        <a-entity id="camera"
          camera
          position="0 .5 2"
          look-controls="pointerLockEnabled: true"></a-entity>

        <a-entity id="left-hand" oculus-touch-controls="hand: left"></a-entity>
        <a-entity id="right-hand" oculus-touch-controls="hand: right"></a-entity>

      </a-entity>

<!--
      <a-entity position="0 0 0">
        <a-cone position=".5 0 0" rotation="0 0 -90" radius-bottom="0.1" radius-top="0" height="1" color="#FF0000"></a-cone>
        <a-cone position="0 .5 0" rotation="0 0 0" radius-bottom="0.1" radius-top="0" height="1" color="#00FF00"></a-cone>
        <a-cone position="0 0 .5" rotation="90 0 0" radius-bottom="0.1" radius-top="0" height="1" color="#0000FF"></a-cone>
      </a-entity>
-->

      <!-- Ocean -->
      <a-ocean width="50" depth="50" density="40" opacity="1" position="0 -3 0"></a-ocean>

      <!-- Sky -->
      <a-sky color="#AADDF0"></a-sky>

      <!-- Lighting -->
      <a-light type="ambient" color="#ccc"></a-light>
      <!--     <a-light color="#ddf" distance="100" intensity="0.4" type="point"></a-light> -->
      <a-light color="#ddf" position="3 10 -10" distance="50" intensity="0.4" type="point"></a-light>

<!--
      <a-text id="text"
        value="Hello, World!"
        color="#333"
        position="0 3 0"
      ></a-text>
-->

      <a-sphere id="pointer" position="0 0 0" radius="0.1" color="#EF2D5E"></a-sphere>

      <a-entity boids__b1="cx: 0; cy: 0; cz: 0; numBoids: 300"></a-entity>

    </a-scene>

    <script>
     const text = document.getElementById('text');
     const message = content => text.setAttribute('value', content);
     Math.seedrandom('hello');





     function initComputeRenderer() {
       const nbBoidsSqrRoot = 128; // Size of the texture containing bird data. Nb boids: 128^2
       gpu_allocation = new GPUComputationRenderer( nbBoidsSqrRoot, nbBoidsSqrRoot, renderer );

       var dtPosition = gpu_allocation.createTexture();
       var dtVelocity = gpu_allocation.createTexture();
       fillPositionTexture( dtPosition );
       fillVelocityTexture( dtVelocity );

       velocity_variable = gpu_allocation.addVariable( "VeloctiyTexture", document.getElementById( 'BoidVelocityFragmentShader' ).textContent, dtVelocity );
       position_variable = gpu_allocation.addVariable( "PositionTexture", document.getElementById( 'BoidPositionFragmentShader' ).textContent, dtPosition );

       gpu_allocation.setVariableDependencies( velocity_variable, [ position_variable, velocity_variable ] );
       gpu_allocation.setVariableDependencies( position_variable, [ position_variable, velocity_variable ] );

       uniform_position = position_variable.material.uniforms;
       uniform_velocity = velocity_variable.material.uniforms;

       uniform_position.clock = { value: 0.0 };
       uniform_position.del_change = { value: 0.0 };
       uniform_velocity.clock = { value: 1.0 };
       uniform_velocity.del_change = { value: 0.0 };
       uniform_velocity.testing = { value: 1.0 };
       uniform_velocity.seperation_distance = { value: 1.0 };
       uniform_velocity.alignment_distance = { value: 1.0 };
       uniform_velocity.cohesion_distance = { value: 1.0 };
       uniform_velocity.freedom_distance = { value: 1.0 };
       uniform_velocity.predator = { value: new THREE.Vector3() };
       velocity_variable.material.defines.bounds = bounds.toFixed( 2 );

       velocity_variable.wrapS = THREE.RepeatWrapping;
       velocity_variable.wrapT = THREE.RepeatWrapping;
       position_variable.wrapS = THREE.RepeatWrapping;
       position_variable.wrapT = THREE.RepeatWrapping;

       var error = gpu_allocation.init();
       if ( error !== null ) {
         console.error( error );
       }
     }



    </script>
  </body>
</html>
